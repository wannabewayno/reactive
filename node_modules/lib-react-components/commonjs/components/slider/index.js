'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _analytics_hoc = require('../../containers/analytics_hoc');

var _analytics_hoc2 = _interopRequireDefault(_analytics_hoc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Verifies min/max range.
 * @param {object} props
 * @param {string} propName
 * @param {string} componentName
 * @returns {object}
 */
function minMaxPropType(props, propName, componentName) {
  for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    rest[_key - 3] = arguments[_key];
  }

  var error = _propTypes2.default.number.apply(_propTypes2.default, [props, propName, componentName].concat(rest));

  if (error !== null) {
    return error;
  }

  if (props.min >= props.max) {
    var errorMsg = propName === 'min' ? 'min should be less than max' : 'max should be greater than min';

    return new Error(errorMsg);
  }

  return null;
}

/**
 * Verifies value is within the min/max range.
 * @param {object} props
 * @param {string} propName
 * @param {string} componentName
 * @returns {object}
 */
function valueInRangePropType(props, propName, componentName) {
  for (var _len2 = arguments.length, rest = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    rest[_key2 - 3] = arguments[_key2];
  }

  var error = _propTypes2.default.number.apply(_propTypes2.default, [props, propName, componentName].concat(rest));

  if (error !== null) {
    return error;
  }

  var value = props[propName];

  if (value < props.min || props.max < value) {
    return new Error(propName + ' should be within the range specified by min and max');
  }

  return null;
}

/**
 * Slider component
 */

var Slider = function (_PureComponent) {
  _inherits(Slider, _PureComponent);

  function Slider() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Slider);

    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Slider.__proto__ || Object.getPrototypeOf(Slider)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      dragging: false,
      value: 0
    }, _this.trackNode = null, _this.dragRunning = false, _this.handleMouseDown = function (event) {
      var _this$props = _this.props,
          disabled = _this$props.disabled,
          onMouseDown = _this$props.onMouseDown;


      if (disabled) {
        return;
      }

      var position = event.clientX - _this.getTrackOffset();

      _this.setValueFromPosition(event, position);

      document.addEventListener('mousemove', _this.handleDragMouseMove);
      document.addEventListener('mouseup', _this.handleMouseEnd);

      _this.onDragStart(event);

      if (onMouseDown) {
        onMouseDown(event);
      }
    }, _this.handleDragMouseMove = function (event) {
      _this.onDragUpdate(event, 'mouse');
    }, _this.handleMouseEnd = function (event) {
      document.removeEventListener('mousemove', _this.handleDragMouseMove);
      document.removeEventListener('mouseup', _this.handleMouseEnd);

      _this.onDragStop(event);
    }, _this.handleTouchStart = function (event) {
      var _this$props2 = _this.props,
          disabled = _this$props2.disabled,
          onTouchStart = _this$props2.onTouchStart;


      if (disabled) {
        return;
      }

      var position = event.touches[0].clientX - _this.getTrackOffset();

      _this.setValueFromPosition(event, position);

      document.addEventListener('touchmove', _this.handleTouchMove);
      document.addEventListener('touchup', _this.handleTouchEnd);
      document.addEventListener('touchend', _this.handleTouchEnd);
      document.addEventListener('touchcancel', _this.handleTouchEnd);

      _this.onDragStart(event);

      // Cancel scroll and context menu
      event.preventDefault();

      if (onTouchStart) {
        onTouchStart(event);
      }
    }, _this.handleTouchMove = function (event) {
      _this.onDragUpdate(event, 'touch');
    }, _this.handleTouchEnd = function (event) {
      document.removeEventListener('touchmove', _this.handleTouchMove);
      document.removeEventListener('touchup', _this.handleTouchEnd);
      document.removeEventListener('touchend', _this.handleTouchEnd);
      document.removeEventListener('touchcancel', _this.handleTouchEnd);

      _this.onDragStop(event);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Slider, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _props = this.props,
          value = _props.value,
          defaultValue = _props.defaultValue,
          min = _props.min;


      var _value = value;

      if (_value === undefined) {
        _value = defaultValue !== undefined ? defaultValue : min;
      }

      this.setState({
        value: this.resolveValue(_value)
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var dragging = this.state.dragging;


      if (nextProps.value !== undefined && !dragging) {
        this.setState({
          value: this.resolveValue(nextProps.value)
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('mousemove', this.handleDragMouseMove);
      document.removeEventListener('mouseup', this.handleMouseEnd);

      document.removeEventListener('touchmove', this.handleTouchMove);
      document.removeEventListener('touchup', this.handleTouchEnd);
      document.removeEventListener('touchend', this.handleTouchEnd);
      document.removeEventListener('touchcancel', this.handleTouchEnd);
    }

    /**
     * Handler onDragStart
     * @param {SynteticEvent} event
     */

  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      var onDragStart = this.props.onDragStart;


      this.setState({
        dragging: true
      });

      if (onDragStart) {
        onDragStart(event);
      }
    }

    /**
     * Handler onDragUpdate
     * @param {SynteticEvent} event
     * @param {string} type
     */

  }, {
    key: 'onDragUpdate',
    value: function onDragUpdate(event, type) {
      var _this2 = this;

      var disabled = this.props.disabled;


      if (this.dragRunning) {
        return;
      }

      this.dragRunning = true;

      requestAnimationFrame(function () {
        _this2.dragRunning = false;
        var source = type === 'touch' ? event.touches[0] : event;
        var position = source.clientX - _this2.getTrackOffset();

        if (!disabled) {
          _this2.setValueFromPosition(event, position);
        }
      });
    }

    /**
     * Handler onDragStop
     * @param {SynteticEvent} event
     */

  }, {
    key: 'onDragStop',
    value: function onDragStop(event) {
      var onDragStop = this.props.onDragStop;


      this.setState({
        dragging: false
      });

      if (onDragStop) {
        onDragStop(event);
      }
    }

    /**
     * Calculate percent from value
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */

  }, {
    key: 'getTrackOffset',


    /**
     * Get track offset left
     * @returns {Number}
     */
    value: function getTrackOffset() {
      return this.trackNode.getBoundingClientRect().left;
    }

    /**
     * Prepare position value and set to state value
     * @param {SynteticEvent} event
     * @param {number} position
     */

  }, {
    key: 'setValueFromPosition',
    value: function setValueFromPosition(event, position) {
      var _props2 = this.props,
          step = _props2.step,
          min = _props2.min,
          max = _props2.max,
          onChange = _props2.onChange;


      var positionMax = this.trackNode.clientWidth;

      var value = void 0;

      if (position <= 0) {
        value = min;
      } else if (position >= positionMax) {
        value = max;
      } else {
        value = position / positionMax * (max - min) + min;
        value = Math.round(value / step) * step;
        value = parseFloat(value.toFixed(5));
      }

      value = this.resolveValue(value);

      if (this.state.value !== value) {
        this.setState({
          value: value
        });

        if (onChange) {
          onChange(event, value);
        }
      }
    }
  }, {
    key: 'resolveValue',


    /**
     * Compare value with min/max props
     * @param {number} value
     * @returns {number}
     */
    value: function resolveValue(value) {
      var _props3 = this.props,
          max = _props3.max,
          min = _props3.min;


      if (value > max) {
        return max;
      }

      if (value < min) {
        return min;
      }

      return value;
    }

    /**
     * Handler onMouseDown
     * @param {SynteticEvent} event
     */


    /**
     * Handler onDragMouseMove
     * @param {SynteticEvent} event
     */


    /**
     * Handler onMouseEnd
     * @param {SynteticEvent} event
     */


    /**
     * Handler onTouchStart
     * @param {SynteticEvent} event
     */


    /**
     * Handler onTouchMove
     * @param {SynteticEvent} event
     */


    /**
     * Handler onTouchEnd
     * @param {SynteticEvent} event
     */

  }, {
    key: 'render',


    /**
     * render
     * @return {ReactElement} markup
     */
    value: function render() {
      var _this3 = this;

      var _props4 = this.props,
          defaultValue = _props4.defaultValue,
          disabled = _props4.disabled,
          max = _props4.max,
          min = _props4.min,
          name = _props4.name,
          onChange = _props4.onChange,
          onDragStart = _props4.onDragStart,
          onDragStop = _props4.onDragStop,
          onMouseDown = _props4.onMouseDown,
          onTouchStart = _props4.onTouchStart,
          required = _props4.required,
          step = _props4.step,
          valueProp = _props4.value,
          className = _props4.className,
          tabIndex = _props4.tabIndex,
          color = _props4.color,
          iconColor = _props4.iconColor,
          progressColor = _props4.progressColor,
          inputProps = _props4.inputProps,
          other = _objectWithoutProperties(_props4, ['defaultValue', 'disabled', 'max', 'min', 'name', 'onChange', 'onDragStart', 'onDragStop', 'onMouseDown', 'onTouchStart', 'required', 'step', 'value', 'className', 'tabIndex', 'color', 'iconColor', 'progressColor', 'inputProps']);

      var value = this.state.value;

      var percent = Slider.getPercent(value, min, max) * 100;

      return _react2.default.createElement(
        'div',
        _extends({
          'data-component': 'slider',
          'data-disabled': disabled,
          tabIndex: tabIndex,
          className: (0, _classnames2.default)('slider', className),
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart
        }, other),
        _react2.default.createElement('div', {
          ref: function ref(node) {
            _this3.trackNode = node;
          },
          className: (0, _classnames2.default)('slider_track', ['fill_' + color])
        }),
        _react2.default.createElement('div', {
          className: (0, _classnames2.default)('slider_progress', ['fill_' + (progressColor || color)]),
          style: {
            width: percent + '%'
          },
          'data-component': 'slider-progress'
        }),
        _react2.default.createElement('div', {
          className: (0, _classnames2.default)('slider_tab', ['fill_' + iconColor]),
          style: {
            left: percent + '%'
          }
        }),
        _react2.default.createElement('input', _extends({}, inputProps, {
          type: 'hidden',
          name: name,
          value: value,
          required: required,
          min: min,
          max: max,
          step: step,
          disabled: disabled
        }))
      );
    }
  }], [{
    key: 'getPercent',
    value: function getPercent(value, min, max) {
      var percent = (value - min) / (max - min);

      if (isNaN(percent)) {
        percent = 0;
      }

      return percent;
    }
  }]);

  return Slider;
}(_react.PureComponent);

Slider.propTypes = {
  /**
   * The default value of the slider
   */
  defaultValue: valueInRangePropType,
  /**
   * If true, the slider will not be interactable
   */
  disabled: _propTypes2.default.bool,
  /**
   * The maximum value the slider can slide to on a scale from 0 to 1 inclusive.
   * Cannot be equal to min
   */
  max: minMaxPropType,
  /**
   * The minimum value the slider can slide to on a scale from 0 to 1 inclusive.
   * Cannot be equal to max
   */
  min: minMaxPropType,
  /**
   * The name of the slider. Behaves like the name attribute of an input element
   */
  name: _propTypes2.default.string,
  /**
   * Callback function that is fired when the slider's value changed
   */
  onChange: _propTypes2.default.func,
  /**
   * Callback function that is fired when the slider has begun to move
   */
  onDragStart: _propTypes2.default.func,
  /**
   * Callback function that is fired when the slider has stopped moving
   */
  onDragStop: _propTypes2.default.func,
  /**
   * Callback function that is fired when the slider mouse down
   */
  onMouseDown: _propTypes2.default.func,
  /**
   * Callback function that is fired when the slider touch start
   */
  onTouchStart: _propTypes2.default.func,
  /**
   * Whether or not the slider is required in a form
   */
  required: _propTypes2.default.bool,
  /**
   * The granularity the slider can step through values
   */
  step: _propTypes2.default.number,
  /**
   * The value of the slider
   */
  value: valueInRangePropType,
  /**
   * The css class name of the root element
   */
  className: _propTypes2.default.string,
  /**
   * The tabIndex attribute for slider
   */
  tabIndex: _propTypes2.default.number,
  /**
   * Component color from theme
   */
  color: _propTypes2.default.string,
  /**
   * Component icon color from theme
   */
  iconColor: _propTypes2.default.string,
  /**
   * Component progress color from theme
   */
  progressColor: _propTypes2.default.string,
  /**
   * Properties for `<input type="hidden" />` element
   */
  inputProps: _propTypes2.default.oneOfType([_propTypes2.default.object])
};
Slider.defaultProps = {
  defaultValue: 0,
  disabled: false,
  max: 1,
  min: 0,
  name: undefined,
  onChange: function onChange() {},
  onDragStart: function onDragStart() {},
  onDragStop: function onDragStop() {},
  onMouseDown: function onMouseDown() {},
  onTouchStart: function onTouchStart() {},

  required: false,
  step: 0.01,
  value: undefined,
  className: '',
  tabIndex: 0,
  color: 'light_grey',
  iconColor: 'primary',
  progressColor: '',
  inputProps: {}
};
exports.default = (0, _analytics_hoc2.default)(Slider, 'onDragStop');
//# sourceMappingURL=index.js.map