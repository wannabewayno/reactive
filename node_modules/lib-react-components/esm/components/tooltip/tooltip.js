var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component, Fragment } from 'react';
import { findDOMNode } from 'react-dom';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import TooltipPopper from './tooltip_popper';
import Portal from '../../containers/portal';

/**
 * Check if node is root element
 * @param {object} root
 * @param {object} n
 */
function contains(root, n) {
  var node = n;

  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }

  return false;
}

/**
 * Tooltip component
 */

var Tooltip = function (_Component) {
  _inherits(Tooltip, _Component);

  function Tooltip(props) {
    _classCallCheck(this, Tooltip);

    var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this));

    _this.timerAutoHide = null;


    _this.state = {
      open: !!props.open
    };

    _this.onFocus = _this.onFocus.bind(_this);
    _this.onBlur = _this.onBlur.bind(_this);
    _this.onClick = _this.onClick.bind(_this);
    _this.onMouseDown = _this.onMouseDown.bind(_this);
    _this.onMouseEnter = _this.onMouseEnter.bind(_this);
    _this.onMouseLeave = _this.onMouseLeave.bind(_this);
    _this.onTouchStart = _this.onTouchStart.bind(_this);
    _this.onDocumentClick = _this.onDocumentClick.bind(_this);

    _this.focusTime = 0;
    _this.preClickTime = 0;
    _this.preTouchTime = 0;
    _this.parentNode = null;
    return _this;
  }

  _createClass(Tooltip, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.isClickToHide()) {
        window.document.addEventListener('mousedown', this.onDocumentClick);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var open = nextProps.open;


      if (open !== undefined) {
        this.setState({
          open: open
        });

        if (open) {
          this._setAutoHideTimer();
        } else if (this.timerAutoHide) {
          clearTimeout(this.timerAutoHide);
          this.timerAutoHide = null;
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.timerAutoHide) {
        clearTimeout(this.timerAutoHide);
        this.timerAutoHide = null;
      }

      window.document.removeEventListener('mousedown', this.onDocumentClick);
    }

    /**
     * onFocus handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onFocus',
    value: function onFocus(e) {
      this.fireEvents('onFocus', e);

      this.focusTime = Date.now();
      this.setOpen(true);
    }

    /**
     * onBlur handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onBlur',
    value: function onBlur(e) {
      this.fireEvents('onBlur', e);

      this.setOpen(false);
    }

    /**
     * onClick handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onClick',
    value: function onClick(e) {
      var open = this.state.open;


      this.fireEvents('onClick', e);

      // focus will trigger click
      if (this.focusTime) {
        var preTime = void 0;

        if (this.preClickTime && this.preTouchTime) {
          preTime = Math.min(this.preClickTime, this.preTouchTime);
        } else if (this.preClickTime) {
          preTime = this.preClickTime;
        } else if (this.preTouchTime) {
          preTime = this.preTouchTime;
        }

        if (Math.abs(preTime - this.focusTime) < 20) {
          return;
        }

        this.focusTime = 0;
      }

      this.preClickTime = 0;
      this.preTouchTime = 0;

      if (e && e.preventDefault) {
        e.preventDefault();
      }

      if (this.isClickToHide() && open || !open && this.isClickToShow()) {
        this.setOpen(!open);
      }
    }

    /**
     * onMouseDown handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.fireEvents('onMouseDown', e);
      this.preClickTime = Date.now();
    }

    /**
     * onMouseEnter handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onMouseEnter',
    value: function onMouseEnter() {
      this.setOpen(true);
    }

    /**
     * onMouseLeave handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onMouseLeave',
    value: function onMouseLeave() {
      this.setOpen(false);
    }

    /**
     * onTouchStart handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onTouchStart',
    value: function onTouchStart(e) {
      this.fireEvents('onTouchStart', e);
      this.preTouchTime = Date.now();
    }

    /**
     * onDocumentClick handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'onDocumentClick',
    value: function onDocumentClick(e) {
      var usePortal = this.props.usePortal;
      var open = this.state.open;
      var target = e.target;

      var tooltipRoot = document.querySelector('[data-component="tooltip_popper"]');

      if (usePortal && tooltipRoot) {
        if (!contains(tooltipRoot, target) && open) {
          this.setOpen(false);
        }

        return;
      }

      var root = findDOMNode(this.parentNode); // eslint-disable-line

      if (!contains(root, target) && open) {
        this.setOpen(false);
      }
    }

    /**
     * Handler for show/hide tooltip
     * @param {boolean} value
     */

  }, {
    key: 'setOpen',
    value: function setOpen(value) {
      var onClose = this.props.onClose;
      var open = this.state.open;


      if (open !== value) {
        if (!('open' in this.props)) {
          this.setState({
            open: value
          });

          if (onClose && !value) {
            onClose();
          }
        }
      }
    }
  }, {
    key: '_setAutoHideTimer',


    /**
     * Set timer for fire onClose callback
     * @param {number} duration
     */
    value: function _setAutoHideTimer() {
      var _this2 = this;

      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var _props = this.props,
          onClose = _props.onClose,
          autoHideDuration = _props.autoHideDuration;


      if (!onClose || !autoHideDuration) {
        return;
      }

      if (this.timerAutoHide) {
        clearTimeout(this.timerAutoHide);
      }

      this.timerAutoHide = setTimeout(function () {
        _this2.timerAutoHide = null;

        if (!onClose || !autoHideDuration) {
          return;
        }

        onClose();
      }, duration || autoHideDuration || 0);
    }

    /**
     * Call callback event props
     * @param {string} type
     * @param {SytheticEvent} e
     */

  }, {
    key: 'fireEvents',
    value: function fireEvents(type, e) {
      var children = this.props.children;

      var callback = this.props[type];
      var childCallback = children.props[type];

      if (childCallback) {
        childCallback(e);
      }

      if (callback) {
        callback(e);
      }
    }
  }, {
    key: 'createTwoChains',
    value: function createTwoChains(event) {
      var childPros = this.props.children.props;
      var props = this.props;

      if (childPros[event] && props[event]) {
        return this['fire' + event];
      }

      return childPros[event];
    }

    /**
     * Check if action prop have `click` string for show tooltip
     * @return {boolean}
     */

  }, {
    key: 'isClickToShow',
    value: function isClickToShow() {
      var action = this.props.action;


      return action.indexOf('click') !== -1;
    }

    /**
     * Check if action prop have `click` string for hide tooltip
     * @return {boolean}
     */

  }, {
    key: 'isClickToHide',
    value: function isClickToHide() {
      var action = this.props.action;


      return action.indexOf('click') !== -1;
    }

    /**
     * Check if action prop have `hover` string for show tooltip
     * @return {boolean}
     */

  }, {
    key: 'isMouseEnterToShow',
    value: function isMouseEnterToShow() {
      var action = this.props.action;


      return action.indexOf('hover') !== -1;
    }

    /**
     * Check if action prop have `hover` string for hide tooltip
     * @return {boolean}
     */

  }, {
    key: 'isMouseLeaveToHide',
    value: function isMouseLeaveToHide() {
      var action = this.props.action;


      return action.indexOf('hover') !== -1;
    }

    /**
     * Check if action prop have `focus` string for show tooltip
     * @return {boolean}
     */

  }, {
    key: 'isFocusToShow',
    value: function isFocusToShow() {
      var action = this.props.action;


      return action.indexOf('focus') !== -1;
    }

    /**
     * Check if action prop have `focus` string for hide tooltip
     * @return {boolean}
     */

  }, {
    key: 'isBlurToHide',
    value: function isBlurToHide() {
      var action = this.props.action;


      return action.indexOf('focus') !== -1;
    }

    /**
     * Handler for delay timer for click current work
     */

  }, {
    key: 'clearDelayTimer',
    value: function clearDelayTimer() {
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    }
  }, {
    key: 'renderOverlay',
    value: function renderOverlay() {
      var _props2 = this.props,
          overlay = _props2.overlay,
          overlayColor = _props2.overlayColor,
          overlayOpacity = _props2.overlayOpacity,
          overlayZIndex = _props2.overlayZIndex,
          overlayProps = _props2.overlayProps,
          action = _props2.action;
      var open = this.state.open;


      if (overlay && action === 'click') {
        var className = overlayProps.className,
            style = overlayProps.style,
            other = _objectWithoutProperties(overlayProps, ['className', 'style']);

        return React.createElement(
          Portal,
          null,
          React.createElement('div', _extends({
            'data-open': open,
            className: classnames('tooltip_overlay', 'fill_' + overlayColor, className),
            style: _extends({
              opacity: open ? overlayOpacity : 0,
              zIndex: overlayZIndex
            }, style)
          }, other))
        );
      }

      return null;
    }

    /**
     * render
     * @return {ReactElement} markup
     */

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props3 = this.props,
          children = _props3.children,
          content = _props3.content,
          action = _props3.action,
          arrow = _props3.arrow,
          placement = _props3.placement,
          positionFixed = _props3.positionFixed,
          C = _props3.component,
          offset = _props3.offset,
          openProp = _props3.open,
          onClose = _props3.onClose,
          autoHideDuration = _props3.autoHideDuration,
          color = _props3.color,
          zIndex = _props3.zIndex,
          overlay = _props3.overlay,
          overlayColor = _props3.overlayColor,
          overlayOpacity = _props3.overlayOpacity,
          overlayZIndex = _props3.overlayZIndex,
          overlayProps = _props3.overlayProps,
          usePortal = _props3.usePortal,
          preventOverflow = _props3.preventOverflow,
          preventFlip = _props3.preventFlip,
          classNameTooltip = _props3.classNameTooltip,
          classNameTooltipContent = _props3.classNameTooltipContent,
          showDelay = _props3.showDelay,
          flipBoundaryElement = _props3.flipBoundaryElement,
          other = _objectWithoutProperties(_props3, ['children', 'content', 'action', 'arrow', 'placement', 'positionFixed', 'component', 'offset', 'open', 'onClose', 'autoHideDuration', 'color', 'zIndex', 'overlay', 'overlayColor', 'overlayOpacity', 'overlayZIndex', 'overlayProps', 'usePortal', 'preventOverflow', 'preventFlip', 'classNameTooltip', 'classNameTooltipContent', 'showDelay', 'flipBoundaryElement']);

      var open = this.state.open;

      var newWrapperProps = Object.assign({}, other);
      var newChildProps = {};

      if (this.isClickToHide() || this.isClickToShow()) {
        newChildProps.onClick = this.onClick;
        newChildProps.onMouseDown = this.onMouseDown;
        newChildProps.onTouchStart = this.onTouchStart;
      } else {
        newChildProps.onClick = this.createTwoChains('onClick');
        newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
        newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
      }

      if (this.isMouseEnterToShow()) {
        newWrapperProps.onMouseOver = this.onMouseEnter;
      }

      if (this.isMouseLeaveToHide()) {
        newWrapperProps.onMouseLeave = this.onMouseLeave;
      }

      if (this.isFocusToShow() || this.isBlurToHide()) {
        newChildProps.onFocus = this.onFocus;
        newChildProps.onBlur = this.onBlur;
      } else {
        newChildProps.onFocus = this.createTwoChains('onFocus');
        newChildProps.onBlur = this.createTwoChains('onBlur');
      }

      return React.createElement(
        Fragment,
        null,
        this.renderOverlay(),
        React.createElement(
          C,
          _extends({}, newWrapperProps, {
            ref: function ref(node) {
              _this3.parentNode = node;
            },
            'data-component': 'tooltip'
          }),
          React.cloneElement(children, newChildProps),
          React.createElement(
            TooltipPopper,
            {
              open: open,
              referenceElement: this.parentNode || {},
              placement: placement,
              positionFixed: positionFixed,
              arrow: arrow,
              offset: offset,
              color: color,
              zIndex: zIndex,
              usePortal: usePortal,
              preventOverflow: preventOverflow,
              preventFlip: preventFlip,
              classNameTooltip: classNameTooltip,
              classNameTooltipContent: classNameTooltipContent,
              showDelay: showDelay,
              flipBoundaryElement: flipBoundaryElement
            },
            content
          )
        )
      );
    }
  }]);

  return Tooltip;
}(Component);

Tooltip.propTypes = {
  /**
   * Tooltip reference element.
   */
  children: PropTypes.element.isRequired,
  /**
   * This is what will be displayed inside the tooltip.
   */
  content: PropTypes.node.isRequired,
  /**
   * Which action cause tooltip shown.
   */
  action: PropTypes.oneOf(['click', 'hover', 'focus', 'none']),
  /**
   * If `true`, the tooltip arrow is shown.
   */
  arrow: PropTypes.bool,
  /**
   * Tooltip placement.
   */
  placement: PropTypes.oneOf(['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']),
  /**
   * Set this to `true` if you want popper to position it self in `fixed` mode.
   */
  positionFixed: PropTypes.bool,
  /**
   * Parent component for tooltip and reference element.
   */
  component: PropTypes.string,
  /**
   * Padding from tooltip to reference element in `px`.
   */
  offset: PropTypes.number,
  /**
   * If `true`, the tooltip is shown.
   */
  open: PropTypes.bool, // eslint-disable-line
  /**
   * Callback fired when the tooltip requests to be closed (works only with `open` prop).
   */
  onClose: PropTypes.func,
  /**
   * The number of milliseconds to wait before automatically calling
   * the onClose function. onClose should then set the state of
   * the open prop to hide the Tooltip. This behavior is disabled by
   * default with the null value.
   */
  autoHideDuration: PropTypes.number,
  /**
   * Color for tooltip component.
   */
  color: PropTypes.string,
  /**
   * Z-index for tooltip component.
   */
  zIndex: PropTypes.number,
  /**
   * If `true`, the tooltip overlay will show for opened tooltip.
   */
  overlay: PropTypes.bool,
  /**
   * Color for tooltip overlay background.
   */
  overlayColor: PropTypes.string,
  /**
   * Opacity for tooltip overlay.
   */
  overlayOpacity: PropTypes.number,
  /**
   * Z-index for tooltip overlay.
   */
  overlayZIndex: PropTypes.number,
  /**
   * HTML props for tooltip overlay.
   */
  overlayProps: PropTypes.oneOfType([PropTypes.object]),
  /**
   * Use React portal for render tooltip to another elemenet.
   */
  usePortal: PropTypes.oneOfType([PropTypes.bool, PropTypes.instanceOf(HTMLElement)]),
  /**
   * Use preventOverflow for prevent overflow on tooltip.
   */
  preventOverflow: PropTypes.bool,
  /**
   * Use preventFlip for prevent flipping tooltip, when no space.
   */
  preventFlip: PropTypes.bool,
  /**
   * Class name for tooltip popper root element
   */
  classNameTooltip: PropTypes.string,
  /**
   * Class name for tooltip popper content element
   */
  classNameTooltipContent: PropTypes.string,
  /**
   * The number of milliseconds to wait before showing the tooltip.
   */
  showDelay: PropTypes.number,
  /**
   * Flip boundary element modifier
   */
  flipBoundaryElement: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(HTMLElement)])
};
Tooltip.defaultProps = {
  action: 'hover',
  arrow: true,
  placement: 'auto',
  positionFixed: true,
  component: 'div',
  offset: 10,
  onClose: function onClose() {},

  autoHideDuration: 0,
  color: 'white',
  zIndex: 1,
  overlay: false,
  overlayColor: 'black',
  overlayOpacity: 0.3,
  overlayZIndex: 0,
  overlayProps: {},
  usePortal: false,
  preventOverflow: true,
  preventFlip: false,
  classNameTooltip: '',
  classNameTooltipContent: '',
  showDelay: 0,
  flipBoundaryElement: 'viewport'
};
export default Tooltip;
//# sourceMappingURL=tooltip.js.map