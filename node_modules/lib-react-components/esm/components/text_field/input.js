var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import RequiredIcon from '../icons/required';

/**
 * Input component
 */

var Input = function (_PureComponent) {
  _inherits(Input, _PureComponent);

  function Input() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Input);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Input.__proto__ || Object.getPrototypeOf(Input)).call.apply(_ref, [this].concat(args))), _this), _this.getValue = function () {
      var _this2 = _this,
          inputNode = _this2.inputNode;


      return inputNode.value;
    }, _this.setFocus = function () {
      var _this3 = _this,
          inputNode = _this3.inputNode;


      inputNode.focus();
    }, _this.inputNode = null, _this.clearValue = function () {
      var _this4 = _this,
          inputNode = _this4.inputNode;


      inputNode.value = '';
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  /**
   * Return input value
   * @return {string}
   */


  /**
   * Set focus to input
   */


  /**
   * Clear input value
   */


  _createClass(Input, [{
    key: '_renderRequiredIcon',


    /**
     * Render required icon element
     * @return {ReactElement} markup
     */
    value: function _renderRequiredIcon() {
      var required = this.props.required;


      return required && React.createElement(RequiredIcon, {
        className: 'input_required_icon fill_wrong'
      });
    }

    /**
     * render
     * @return {ReactElement} markup
     */

  }, {
    key: 'render',
    value: function render() {
      var _this5 = this,
          _classNames;

      var _props = this.props,
          tabIndex = _props.tabIndex,
          className = _props.className,
          defaultValue = _props.defaultValue,
          disabled = _props.disabled,
          multiLine = _props.multiLine,
          onChange = _props.onChange,
          type = _props.type,
          value = _props.value,
          required = _props.required,
          valid = _props.valid,
          placeholder = _props.placeholder,
          placeholderColor = _props.placeholderColor,
          children = _props.children,
          name = _props.name,
          bgType = _props.bgType,
          color = _props.color,
          textColor = _props.textColor,
          colorFocus = _props.colorFocus,
          propsSize = _props.size,
          mobileSize = _props.mobileSize,
          inputProps = _props.inputProps,
          autoComplete = _props.autoComplete,
          autoFocus = _props.autoFocus,
          other = _objectWithoutProperties(_props, ['tabIndex', 'className', 'defaultValue', 'disabled', 'multiLine', 'onChange', 'type', 'value', 'required', 'valid', 'placeholder', 'placeholderColor', 'children', 'name', 'bgType', 'color', 'textColor', 'colorFocus', 'size', 'mobileSize', 'inputProps', 'autoComplete', 'autoFocus']);

      var device = this.context.device;

      var classNameInput = inputProps.className,
          otherInputProps = _objectWithoutProperties(inputProps, ['className']);

      var Component = multiLine ? 'textarea' : 'input';

      // {label && (
      //   <div
      //     onClick={this.setFocus}
      //     className={s.label}
      //     ref={(node) => { this.labelNode = node; }}
      //   >
      //     {label}
      //   </div>
      // )}

      var size = propsSize || Input.defaultProps.size;

      if (device && mobileSize) {
        if (device.type === 'mobile') {
          size = mobileSize;
        }
      }

      return React.createElement(
        'div',
        _extends({
          'data-component': 'input',
          'data-type': bgType,
          'data-valid': valid,
          'data-disabled': disabled,
          className: classNames('input', className)
        }, other),
        React.createElement(Component, _extends({
          ref: function ref(node) {
            _this5.inputNode = node;
          },
          type: multiLine ? null : type,
          className: classNames('input_field', 'round_small', ['input_field_' + size], ['stroke_' + color], (_classNames = {
            fill_white: bgType === 'stroke'
          }, _defineProperty(_classNames, 'fill_' + color, bgType === 'fill'), _defineProperty(_classNames, 'text_' + textColor, textColor), _classNames), ['input_field_focus_' + colorFocus], ['input_placeholder_color_' + placeholderColor], classNameInput),
          tabIndex: tabIndex,
          defaultValue: defaultValue,
          disabled: disabled,
          onChange: onChange,
          value: value,
          required: required,
          placeholder: placeholder,
          name: name,
          autoComplete: autoComplete,
          autoFocus: autoFocus
        }, otherInputProps)),
        this._renderRequiredIcon(),
        children
      );
    }
  }]);

  return Input;
}(PureComponent);

Input.propTypes = {
  /**
   * Element tabIndex.
   */
  tabIndex: PropTypes.number,
  /**
   * The CSS class name of the wrapper element.
   */
  className: PropTypes.string,
  /**
   * The default input value, useful when not controlling the component.
   */
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /**
   * If true, the input will be disabled.
   */
  disabled: PropTypes.bool,
  /**
   * If true, a textarea element will be rendered.
   */
  multiLine: PropTypes.bool,
  /**
   * Callback fired when the value is changed.
   */
  onChange: PropTypes.func,
  /**
   * Type of the input element. It should be a valid HTML5 input type.
   */
  type: PropTypes.string,
  /**
   * The input value, required for a controlled component.
   */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /**
   * If true, the input will be required.
   */
  required: PropTypes.bool,
  /**
   * If false, the input will be unvalid styles.
   */
  valid: PropTypes.bool,
  /**
   * The short hint displayed in the input before the user enters a value.
   */
  placeholder: PropTypes.string,
  /**
   * Color for placeholder
   */
  placeholderColor: PropTypes.string,
  // label: PropTypes.string,
  /**
   * This is what will be displayed in wrapper component
   */
  children: PropTypes.node,
  /**
   * Name attribute of the input element.
   */
  name: PropTypes.string,
  /**
   * Component type one of `fill` or `stroke`.
   * If `fill` - component will be have background-color from `color` props.
   * If `stroke` - component will be have border-color from `color` props.
   */
  bgType: PropTypes.oneOf(['fill', 'stroke']),
  /**
   * Component color from theme
   */
  color: PropTypes.string,
  /**
   * Component text color from theme
   */
  textColor: PropTypes.string,
  /**
   * Component focus color from theme
   */
  colorFocus: PropTypes.string,
  /**
   * Component size.
   */
  size: PropTypes.oneOf(['medium', 'large']),
  /**
   * Component size for mobile.
   */
  mobileSize: PropTypes.oneOf(['medium', 'large']),
  /**
   * Properties applied to the input element.
   */
  inputProps: PropTypes.oneOfType([PropTypes.object]),
  /**
   * This property helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   */
  autoComplete: PropTypes.string,
  /**
   * If true, the input will be focused during the first mount.
   */
  autoFocus: PropTypes.bool
};
Input.contextTypes = {
  device: PropTypes.object
};
Input.defaultProps = {
  tabIndex: 0,
  className: '',
  defaultValue: undefined,
  disabled: false,
  multiLine: false,
  onChange: null,
  type: 'text',
  value: undefined,
  required: false,
  valid: true,
  placeholder: undefined,
  placeholderColor: 'grey_4',
  // label: undefined,
  children: null,
  name: undefined,
  bgType: 'fill',
  color: 'light_grey',
  textColor: 'black',
  colorFocus: 'primary',
  size: 'medium',
  mobileSize: undefined,
  inputProps: {},
  autoComplete: undefined,
  autoFocus: false
};
export default Input;
//# sourceMappingURL=input.js.map