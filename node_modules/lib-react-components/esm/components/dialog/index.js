var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import Button from '../button';
// import s from './styles/index.sss';

var s = {};

/**
 * @class Dialog - Dialog component
 * @example
 *  // Basic usage
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *    />
 *  );
 *
 * @example
 *  // With content
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *    >
 *      Dialog description
 *    </Dialog>
 *  );
 *
 * @example
 *  // Change buttons text
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *      cancelText="Disagree"
 *      acceptText="Agree"
 *    />
 *  );
 *
 * @example
 *  // Change buttons props
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *      cancelButtonProps={{
 *        style: {
 *          opacity: '0.7',
 *        },
 *      }}
 *      acceptButtonProps={{
 *        style: {
 *          opacity: '0.8',
 *        },
 *      }}
 *    />
 *  );
 *
 * @example
 *  // Buttons swap
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *      swapButtons
 *    />
 *  );
 *
 * @example
 *  // With classNames
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *      className="my-wrapper-class"
 *      classNameOverlay="my-overlay-class"
 *      classNameDialog="my-dialog-class"
 *    />
 *  );
 *
 * @example
 *  // With events
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *      onCancel={(e) => { console.log(e); }}
 *      onAccept={(e) => { console.log(e); }}
 *      onClose={(e) => { console.log(e); }}
 *    />
 *  );
 *
 * @example
 *  // With not documented props
 *  import Dialog from './path/to/dialog';
 *
 *  const DialogExample = () => (
 *    <Dialog
 *      title="Dialog title"
 *      style={{
 *        height: '500px',
 *      }}
 *    />
 *  );
 */

var Dialog = function (_PureComponent) {
  _inherits(Dialog, _PureComponent);

  function Dialog() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Dialog);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Dialog.__proto__ || Object.getPrototypeOf(Dialog)).call.apply(_ref, [this].concat(args))), _this), _this.onEscapePress = function (e) {
      var onClose = _this.props.onClose;


      if (e.keyCode === 27 && onClose) {
        onClose(e);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }
  /**
   * PropTypes
   * @type {{
   *  title: string
   *  children: array
   *  cancelText: array
   *  cancelButtonProps: object
   *  acceptText: array
   *  acceptButtonProps: object
   *  swapButtons: boolean
   *  className: string
   *  classNameOverlay: string
   *  classNameDialog: string
   *  smooth: boolean
   *  onCancel: function
   *  onAccept: function
   *  onClose: function
   * }}
   */


  _createClass(Dialog, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      document.addEventListener('keydown', this.onEscapePress);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('keydown', this.onEscapePress);
    }

    /**
     * onKeyDown handler
     * @param {SytheticEvent} e
     */

  }, {
    key: 'renderCancelButton',


    /**
     * Render cancel button
     * @return {ReactElement} markup
     */
    value: function renderCancelButton() {
      var _props = this.props,
          cancelText = _props.cancelText,
          cancelButtonProps = _props.cancelButtonProps,
          onCancel = _props.onCancel;


      return cancelText && React.createElement(
        Button,
        _extends({
          size: 'small',
          className: s.button,
          onClick: onCancel
        }, cancelButtonProps),
        cancelText
      );
    }

    /**
     * Render accept button
     * @return {ReactElement} markup
     */

  }, {
    key: 'renderAcceptButton',
    value: function renderAcceptButton() {
      var _props2 = this.props,
          acceptText = _props2.acceptText,
          acceptButtonProps = _props2.acceptButtonProps,
          onAccept = _props2.onAccept;


      return acceptText && React.createElement(
        Button,
        _extends({
          primary: true,
          size: 'small',
          className: s.button,
          onClick: onAccept,
          autoFocus: true
        }, acceptButtonProps),
        acceptText
      );
    }

    /**
     * Render buttons
     * @return {ReactElement} markup
     */

  }, {
    key: 'renderButtons',
    value: function renderButtons() {
      var _props3 = this.props,
          cancelText = _props3.cancelText,
          acceptText = _props3.acceptText,
          swapButtons = _props3.swapButtons;


      return (acceptText || cancelText) && React.createElement(
        'div',
        { className: s.buttons },
        !swapButtons && this.renderCancelButton(),
        this.renderAcceptButton(),
        swapButtons && this.renderCancelButton()
      );
    }

    /**
     * render
     * @return {ReactElement} markup
     */

  }, {
    key: 'render',
    value: function render() {
      var _props4 = this.props,
          title = _props4.title,
          children = _props4.children,
          cancelText = _props4.cancelText,
          acceptText = _props4.acceptText,
          swapButtons = _props4.swapButtons,
          cancelButtonProps = _props4.cancelButtonProps,
          acceptButtonProps = _props4.acceptButtonProps,
          className = _props4.className,
          classNameOverlay = _props4.classNameOverlay,
          classNameDialog = _props4.classNameDialog,
          smooth = _props4.smooth,
          onCancel = _props4.onCancel,
          onAccept = _props4.onAccept,
          onClose = _props4.onClose,
          other = _objectWithoutProperties(_props4, ['title', 'children', 'cancelText', 'acceptText', 'swapButtons', 'cancelButtonProps', 'acceptButtonProps', 'className', 'classNameOverlay', 'classNameDialog', 'smooth', 'onCancel', 'onAccept', 'onClose']);

      return React.createElement(
        'div',
        _extends({
          className: classNames(s.c_dialog_wrapper, className, _defineProperty({}, s.m_smooth, smooth))
        }, other),
        React.createElement('div', {
          className: classNames(s.overlay, classNameOverlay),
          onClick: onClose
        }),
        React.createElement(
          'div',
          { className: s.container },
          React.createElement(
            'div',
            {
              className: classNames(s.dialog, classNameDialog)
            },
            title && React.createElement(
              'h3',
              { className: classNames(s.title, 'break_word') },
              title
            ),
            React.createElement(
              'div',
              { className: s.content },
              children
            ),
            this.renderButtons()
          )
        )
      );
    }
  }]);

  return Dialog;
}(PureComponent);

Dialog.propTypes = {
  /**
   * The title to display on the Dialog. Could be number, string, element
   * or an array containing these types
   */
  title: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.node]),
  /**
   * The contents of the Dialog
   */
  children: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.node]),
  /**
   * The value to display on the Dialog cancel button. Could be number, string, element
   * or an array containing these types
   */
  cancelText: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.node]),
  /**
   * The cancel button props
   */
  cancelButtonProps: PropTypes.oneOfType([PropTypes.object]),
  /**
   * The value to display on the Dialog accept button. Could be number, string, element
   * or an array containing these types
   */
  acceptText: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.node]),
  /**
   * The accept button props
   */
  acceptButtonProps: PropTypes.oneOfType([PropTypes.object]),
  /**
   * If set to true, Dialog buttons will turn over
   */
  swapButtons: PropTypes.bool,
  /**
   * The css class name of the root element
   */
  className: PropTypes.string,
  /**
   * The css class name of the overlay element
   */
  classNameOverlay: PropTypes.string,
  /**
   * The css class name of the content container element
   */
  classNameDialog: PropTypes.string,
  smooth: PropTypes.bool,
  /**
   * Fired when 'cancel' button click
   */
  onCancel: PropTypes.func,
  /**
   * Fired when 'accept' button click
   */
  onAccept: PropTypes.func,
  /**
   * Fired when the Dialog is requested to be closed by a click outside
   * the Dialog or press escape button
   */
  onClose: PropTypes.func
};
Dialog.defaultProps = {
  title: '',
  children: null,
  cancelText: 'Cancel',
  cancelButtonProps: {},
  acceptText: 'Accept',
  acceptButtonProps: {},
  swapButtons: false,
  className: '',
  classNameOverlay: '',
  classNameDialog: '',
  smooth: false,
  onCancel: null,
  onAccept: null,
  onClose: null
};
export default Dialog;
//# sourceMappingURL=index.js.map